# 入门
## 元字符
- `\b` 匹配单词边界
    - `\bword\b` 匹配独立的单词 "word"。
    - `\bword` 匹配以 "word" 开头的单词。
    - `word\b` 匹配以 "word" 结尾的单词。


```python
import re

# 示例文本
text = "This is a test. Testing the word boundary."

# 匹配独立的单词 "test"
pattern = r'\btest\b'
matches = re.findall(pattern, text)
print("匹配独立的单词 'test':", matches)

# 匹配以 "test" 开头的单词
pattern = r'\btest'
matches = re.findall(pattern, text)
print("匹配以 'test' 开头的单词:", matches)

# 匹配以 "test" 结尾的单词
pattern = r'test\b'
matches = re.findall(pattern, text)
print("匹配以 'test' 结尾的单词:", matches)

```

- `.`除了换行符以外的任意字符


```python
import re

# 示例文本
text = "cat bat rat mat"

# 匹配以`at`结尾，任意字符开头的，包含三个字母的字符串
pattern = r'.at'
matches = re.findall(pattern, text)
print("匹配结果:", matches)
```

- `*`前面的字符或子模式可以重复零次或多次


```python
import re

# 示例文本
text = "aaa ab aab abb b"

# 匹配0个或者多个'a'后面跟了一个'b'
pattern = r'a*b'
matches = re.findall(pattern, text)
print("匹配结果:", matches)
```

**结果分析**
'abb'：匹配，因为有一个 a 后面跟一个 b。这里匹配的是 ab，剩下的 b 还会继续匹配。

**思考**
下面的正则表达式匹配什么？
'\bhi\b.*\bluck\b'

**结果分析**
上述字符串匹配的内容是:单词'hi'，后面跟随任意字符(但是不能换行)，最后跟随单词'luck'。



```python
import re

text1 = 'hi i am luck'
text2 = 'hit luck'

pattern = r'\bhi\b.*\bluck\b'
print("text1 匹配结果:", re.search(pattern, text1))
print("text2 匹配结果:", re.search(pattern, text2))
```

- '\d'匹配数字


```python
import re

text = "18812344321"

# 匹配中国的个人手机号:一1开头，然后跟着10个数字
pattern = r'1\d\d\d\d\d\d\d\d\d\d'
print("text 匹配结果: ", re.match(pattern, text))
```

- 正则表达式中的量词
显然，上一个例子中，我们使用了连续10个`\d`来匹配中国的个人手机号，这并不是一个简洁和灵活的正则表达式。我们可以使用量词来简化这个正则表达式。
量词的具体用法如下
    - `*`：匹配前面的字符零次或多次。例如，`a*` 可以匹配空字符串、`a`、`aa` 等。
    - `+`：匹配前面的字符一次或多次。例如，`a+` 可以匹配 `a`、`aa`、`aaa` 等。
    - `?`：匹配前面的字符零次或一次。例如，`a?` 可以匹配空字符串或 `a`。
    - `{n}`：匹配前面的字符恰好 `n` 次。例如，`a{3}` 可以匹配 `aaa`。
    - `{n,}`：匹配前面的字符至少 `n` 次。例如，`a{2,}` 可以匹配 `aa`、`aaa`、`aaaa` 等。
    - `{n,m}`：匹配前面的字符至少 `n` 次，至多 `m` 次。例如，`a{2,4}` 可以匹配 `aa`、`aaa` 或 `aaaa`。

结合上一个例子，我们可以使用 `r'1\d{10}'` 来匹配中国的个人手机号。


```python
import re

text = "18812344321"

pattern = r'1\d{10}'
print("text的匹配结果: ", re.match(pattern, text))
```

- `\s`匹配任意的空白符，包括空格，制表符(Tab)，换行符，中文全角空格等。
- `\w`匹配字母或数字或下划线或汉字

## 测试正则表达式
使用在线网站编写和测试正则表达式: [wegester](https://deerchao.cn/tools/wegester/)

![](https://raw.githubusercontent.com/ZhouQiang19980220/picgo-images/main/20240730202310.png)

- `\ba\w*\b`: 匹配以字母 `a` 开头的单词，例如 `apple`、`application` 等。
- `\d+`匹配1个或更多连续的数字。
- `\b\w{6}\b`: 匹配6个字符的单词。

常见的元字符总结为下表

![](https://raw.githubusercontent.com/ZhouQiang19980220/picgo-images/main/20240730203005.png)

## 字符转义
如果你想查找元字符本身的话，比如你查找`.`或者`*`,就出现了问题：你没办法指定它们，因为它们会被解释成别的意思。
这时你就得使用`\`来取消这些字符的特殊意义。因此，你应该使用`\.`和`\*`。当然，要查找`\`本身，你也得用`\\`。

例如：`deerchao\.cn`匹配'deerchao.cn'，`C:\\Windows`匹配`C:\Windows`。

## 字符类
要想查找数字，字母或数字，空白是很简单的，因为已经有了对应这些字符集合的元字符，但是如果你想匹配没有预定义元字符的字符集合(比如元音字母a,e,i,o,u),应该怎么办？

很简单，你只需要在方括号里列出它们就行了，像[aeiou]就匹配任何一个英文元音字母，[.?!]匹配标点符号(.或?或!)。

我们也可以轻松地指定一个字符范围，像[0-9]代表的含意与\d就是完全一致的：一位数字；同理[a-z0-9A-Z_]也完全等同于\w（如果只考虑英文的话）。

# TODO
- 分枝条件
- 分组
- 反义
- 后向引用
- 零宽断言
- 负向零宽断言
- 注释
- 贪婪与懒惰
- 处理选项
- 平衡组/递归匹配


## 参考资料
> [正则表达式30分钟入门教程](https://deerchao.cn/tutorials/regex/regex.htm)
