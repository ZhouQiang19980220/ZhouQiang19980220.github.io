---
layout: post
title: YOLOv8æ˜¯å¦‚ä½•é€šè¿‡yamlæ„å»ºæ¨¡å‹çš„?
tags: [YOLO]
author: Tenacity Wick
---
1. **Ultralytics**ï¼š[YOLOv8 çš„å®˜æ–¹ä»“åº“](https://github.com/ultralytics/ultralytics)ã€‚
2. [å¦‚ä½•å®‰è£… YOLOv8](https://zhouqiang19980220.github.io/2024-07-28-%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85YOLOv8/)
# YOLOv8æ˜¯å¦‚ä½•é€šè¿‡yamlæ„å»ºæ¨¡å‹çš„

## ä¸€äº›æ•™ç¨‹

YOLOv8çš„æ ¸å¿ƒä»£ç åœ¨å¦‚ä¸‹ç›®å½•ï¼š`ultralytics/ultralytics`

ä¸€äº›ä½¿ç”¨ç¤ºä¾‹å’Œæ•™ç¨‹çš„ä»£ç `ultralytics/examples`

[æ•™ç¨‹](https://github.com/ZhouQiang19980220/ultralytics/blob/main/examples/tutorial.ipynb)

ä½¿ç”¨ python æ„å»ºæ¨¡å‹ã€è®­ç»ƒã€æµ‹è¯•ã€æ¨ç†ã€éƒ¨ç½²

```python
from ultralytics import YOLO

# Load a model
model = YOLO('yolov8n.yaml')  # build a new model from scratch
model = YOLO('yolov8n.pt')  # load a pretrained model (recommended for training)

# Use the model
results = model.train(data='coco8.yaml', epochs=3)  # train the model
results = model.val()  # evaluate model performance on the validation set
results = model('https://ultralytics.com/images/bus.jpg')  # predict on an image
results = model.export(format='onnx')  # export the model to ONNX format
```

æ³¨æ„åˆ°`model = YOLO('yolov8n.yaml')  # build a new model from scratch`è¿™è¡Œä»£ç å¯ä»¥é€šè¿‡`yolov8n.yaml`æ¥æ„å»ºæ¨¡å‹ã€‚

ä½†æ˜¯æˆ‘åœ¨é˜…è¯»æºç çš„è¿‡ç¨‹ä¸­ï¼Œæ‰¾äº†å¾ˆä¹…éƒ½æ²¡æœ‰æ‰¾åˆ°è¿™ä¸ªæ‰€è°“çš„`yolov8n.yaml`æ–‡ä»¶ã€‚æœ€ç»ˆåœ¨`ultralytics/cfg/models/v8/yolov8.yaml`æ‰¾åˆ°äº†é…ç½®æ–‡ä»¶ï¼ˆæ³¨æ„è¿™é‡Œçš„æ–‡ä»¶åä¸æ˜¯`yolov8n.yaml`ï¼Œè€Œæ˜¯`yolov8.yaml`ï¼‰ï¼Œè¯¥æ–‡ä»¶çš„å†…å®¹å®šä¹‰å¦‚ä¸‹ï¼Œå¤§ä½“åˆ†ä¸º 4 ä¸ªéƒ¨åˆ†

1. **é€šç”¨å‚æ•°çš„å®šä¹‰**`nc`ï¼šè¿™é‡Œä¿®æ”¹ä¸ºè‡ªå®šä¹‰æ•°æ®é›†çš„å®é™…ç±»åˆ«æ•°ï¼›é»˜è®¤80 æ˜¯å› ä¸º COCO æ•°æ®é›†ä¸­æœ‰ 80 ä¸ªç±»åˆ«ã€‚
2. **å°ºåº¦**ï¼šä»å°åˆ°å¤§å…±æœ‰ 5 ç§ä¸åŒå°ºåº¦çš„æ¨¡å‹ã€‚
3. **backbone çš„å®šä¹‰**ã€‚
4. **head çš„å®šä¹‰ï¼šéœ€è¦ç”¨åˆ°`nc`è¿™ä¸ªå‚æ•°**ã€‚

```yaml
# Ultralytics YOLO ğŸš€, AGPL-3.0 license
# YOLOv8 object detection model with P3-P5 outputs. For Usage examples see https://docs.ultralytics.com/tasks/detect

# Parameters
nc: 80 # number of classes
scales: # model compound scaling constants, i.e. 'model=yolov8n.yaml' will call yolov8.yaml with scale 'n'
  # [depth, width, max_channels]
  n: [0.33, 0.25, 1024] # YOLOv8n summary: 225 layers,  3157200 parameters,  3157184 gradients,   8.9 GFLOPs
  s: [0.33, 0.50, 1024] # YOLOv8s summary: 225 layers, 11166560 parameters, 11166544 gradients,  28.8 GFLOPs
  m: [0.67, 0.75, 768] # YOLOv8m summary: 295 layers, 25902640 parameters, 25902624 gradients,  79.3 GFLOPs
  l: [1.00, 1.00, 512] # YOLOv8l summary: 365 layers, 43691520 parameters, 43691504 gradients, 165.7 GFLOPs
  x: [1.00, 1.25, 512] # YOLOv8x summary: 365 layers, 68229648 parameters, 68229632 gradients, 258.5 GFLOPs

# YOLOv8.0n backbone
backbone:
  # [from, repeats, module, args]
  - [-1, 1, Conv, [64, 3, 2]] # 0-P1/2
  - [-1, 1, Conv, [128, 3, 2]] # 1-P2/4
  - [-1, 3, C2f, [128, True]]
  - [-1, 1, Conv, [256, 3, 2]] # 3-P3/8
  - [-1, 6, C2f, [256, True]]
  - [-1, 1, Conv, [512, 3, 2]] # 5-P4/16
  - [-1, 6, C2f, [512, True]]
  - [-1, 1, Conv, [1024, 3, 2]] # 7-P5/32
  - [-1, 3, C2f, [1024, True]]
  - [-1, 1, SPPF, [1024, 5]] # 9

# YOLOv8.0n head
head:
  - [-1, 1, nn.Upsample, [None, 2, "nearest"]]
  - [[-1, 6], 1, Concat, [1]] # cat backbone P4
  - [-1, 3, C2f, [512]] # 12

  - [-1, 1, nn.Upsample, [None, 2, "nearest"]]
  - [[-1, 4], 1, Concat, [1]] # cat backbone P3
  - [-1, 3, C2f, [256]] # 15 (P3/8-small)

  - [-1, 1, Conv, [256, 3, 2]]
  - [[-1, 12], 1, Concat, [1]] # cat head P4
  - [-1, 3, C2f, [512]] # 18 (P4/16-medium)

  - [-1, 1, Conv, [512, 3, 2]]
  - [[-1, 9], 1, Concat, [1]] # cat head P5
  - [-1, 3, C2f, [1024]] # 21 (P5/32-large)

  - [[15, 18, 21], 1, Detect, [nc]] # Detect(P3, P4, P5)
```

è‡³æ­¤ï¼Œæˆ‘ä»ç„¶æœ‰ä¸€äº›å›°æƒ‘

1. ``model = YOLO('yolov8n.yaml')`è¿™è¡Œä»£ç å¹¶æ²¡æœ‰ç»™å‡º`yolov8n.yaml`çš„è·¯å¾„ï¼ŒYOLO æ˜¯å¦‚ä½•æ‰¾åˆ°å¯¹åº”çš„æ–‡ä»¶çš„ï¼Ÿ

   ä¸€ä¸ªç®€å•çš„æƒ³æ³•æ˜¯é¢„å®šä¹‰äº†yaml æ–‡ä»¶çš„åœ°å€ï¼Œç„¶åç›´æ¥åˆ°é¢„å®šä¹‰çš„ç›®å½•ä¸­å¯»æ‰¾å³å¯ï¼ˆäº‹å®ä¸Šä¸æ˜¯è¿™æ ·çš„ï¼‰

2. æ„å»ºæ¨¡å‹æ—¶ä¼ å…¥çš„å‚æ•°æ˜¯`yolov8n.yaml`ï¼Œä½†æ˜¯æˆ‘æ‰¾åˆ°çš„ `yaml`å´æ˜¯`yolov8.yaml`ã€‚

## YOLOv8æ˜¯å¦‚ä½•é€šè¿‡yamlæ„å»ºæ¨¡å‹çš„

### å‡†å¤‡å·¥ä½œ

1. æŒ‰ç…§[æ•™ç¨‹](https://zhouqiang19980220.github.io/2024-07-28-%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85YOLOv8/)å®‰è£… YOLOv8ã€‚

2. å®‰è£… [viztracer](https://github.com/gaogaotiantian/viztracer)

   > VizTracer is a low-overhead logging/debugging/profiling tool that can trace and visualize your python code execution.
   >
   > The front-end UI is powered by Perfetto. Use "AWSD" to zoom/navigate. More help can be found in "Support - Controls".

â€‹		ä¸Šé¢æ˜¯ viztracer å®˜æ–¹ä»“åº“çš„ä»‹ç»ï¼Œå¼€å‘è€…æ˜¯ python core devï¼šç å†œé«˜å¤©ã€‚

### ä½¿ç”¨viztracerè¿½è¸ªä»£ç çš„è°ƒç”¨è¿‡ç¨‹

1. æ–°å»ºä¸€ä¸ªpython æ–‡ä»¶ï¼Œå†…å®¹å¦‚ä¸‹

   ```python
   from ultralytics import YOLO
   
   model = YOLO('yolov8n.yaml')
   ```

2. ä½¿ç”¨ viztracer æ‰§è¡Œä¸Šé¢çš„ py æ–‡ä»¶ã€‚

   ```bash
   viztracer <python-file.py>
   ```

   æ‰§è¡Œå®Œæˆåä¼šç”Ÿæˆä¸€ä¸ª`result.json`çš„æ–‡ä»¶

3. ä½¿ç”¨ vizviewerå¯è§†åŒ–`result.json`

   ```bash
   vizviewer result.json
   ```

   å¦‚æœåœ¨è¿œç¨‹å¼€å‘ï¼Œæ²¡æœ‰å¯è§†åŒ–ç¯å¢ƒï¼Œå¯ä»¥å°†`result.json`ä¸‹è½½åˆ°æœ¬åœ°åå†è¿è¡Œä¸Šè¿°å‘½ä»¤

   é»˜è®¤æƒ…å†µä¸‹ï¼Œä½¿ç”¨æµè§ˆå™¨æ‰“å¼€`http://127.0.0.1:9001/`å³å¯ã€‚

   å¯è§†åŒ–ç•Œé¢å¦‚ä¸‹ï¼Œå¯ä»¥å¾ˆæ–¹ä¾¿çš„è§‚å¯Ÿå‡½æ•°çš„è°ƒç”¨å…³ç³»ã€‚

   ![image-20240728124952200](https://p.ipic.vip/j0rac4.png)

# å‡½æ•°çš„è°ƒç”¨å…³ç³»

1. `ultralytics/models/yolo/model.py`

`super().__init__(model=model, task=task, verbose=verbose)`

```python
class YOLO(Model):
    """YOLO (You Only Look Once) object detection model."""

    def __init__(self, model="yolov8n.pt", task=None, verbose=False):
        """Initialize YOLO model, switching to YOLOWorld if model filename contains '-world'."""
        path = Path(model)
        if "-world" in path.stem and path.suffix in {".pt", ".yaml", ".yml"}:  # if YOLOWorld PyTorch model
            new_instance = YOLOWorld(path, verbose=verbose)
            self.__class__ = type(new_instance)
            self.__dict__ = new_instance.__dict__
        else:
            # Continue with default YOLO initialization
            super().__init__(model=model, task=task, verbose=verbose)
```

2. `ultralytics/ultralytics/engine/model.py`

`self._new(model, task=task, verbose=verbose)`

```python
class Model(nn.Module):
    def __init__(
        self,
        model: Union[str, Path] = "yolov8n.pt",
        task: str = None,
        verbose: bool = False,
    ) -> None:
        super().__init__()
        self.callbacks = callbacks.get_default_callbacks()
        self.predictor = None  # reuse predictor
        self.model = None  # model object
        self.trainer = None  # trainer object
        self.ckpt = None  # if loaded from *.pt
        self.cfg = None  # if loaded from *.yaml
        self.ckpt_path = None
        self.overrides = {}  # overrides for trainer object
        self.metrics = None  # validation/training metrics
        self.session = None  # HUB session
        self.task = task  # task type
        model = str(model).strip()

        # Check if Ultralytics HUB model from https://hub.ultralytics.com
        if self.is_hub_model(model):
            # Fetch model from HUB
            checks.check_requirements("hub-sdk>=0.0.8")
            self.session = HUBTrainingSession.create_session(model)
            model = self.session.model_file

        # Check if Triton Server model
        elif self.is_triton_model(model):
            self.model_name = self.model = model
            return

        # Load or create new YOLO model
        if Path(model).suffix in {".yaml", ".yml"}:
            self._new(model, task=task, verbose=verbose)
        else:
            self._load(model, task=task)
```

3. `ultralytics/ultralytics/engine/model.py`

`cfg_dict = yaml_model_load(cfg)`

```python
def _new(self, cfg: str, task=None, model=None, verbose=False) -> None:

        cfg_dict = yaml_model_load(cfg)
        self.cfg = cfg
        self.task = task or guess_model_task(cfg_dict)
        self.model = (model or self._smart_load("model"))(cfg_dict, verbose=verbose and RANK == -1)  					# build model
        self.overrides["model"] = self.cfg
        self.overrides["task"] = self.task

        # Below added to allow export from YAMLs
        self.model.args = {**DEFAULT_CFG_DICT, **self.overrides} 
        self.model.task = self.task
        self.model_name = cfg
```

4. `ultralytics/ultralytics/nn/tasks.py`

`yaml_file = check_yaml(unified_path, hard=False) or check_yaml(path)`

```python
def yaml_model_load(path):
    """Load a YOLOv8 model from a YAML file."""
    import re

    path = Path(path)
    if path.stem in (f"yolov{d}{x}6" for x in "nsmlx" for d in (5, 8)):
        new_stem = re.sub(r"(\d+)([nslmx])6(.+)?$", r"\1\2-p6\3", path.stem)
        LOGGER.warning(f"WARNING âš ï¸ Ultralytics YOLO P6 models now use -p6 suffix. Renaming {path.stem} to {new_stem}.")
        path = path.with_name(new_stem + path.suffix)

    unified_path = re.sub(r"(\d+)([nslmx])(.+)?$", r"\1\3", str(path))  # i.e. yolov8x.yaml -> yolov8.yaml
    yaml_file = check_yaml(unified_path, hard=False) or check_yaml(path)
    d = yaml_load(yaml_file)  # model dict
    d["scale"] = guess_model_scale(path)
    d["yaml_file"] = str(path)
    return d
```

5. `ultralytics/ultralytics/utils/checks.py`

```python
def check_yaml(file, suffix=(".yaml", ".yml"), hard=True):
    """Search/download YAML file (if necessary) and return path, checking suffix."""
    return check_file(file, suffix, hard=hard)
```

6. `ultralytics/ultralytics/utils/checks.py`

```python
def check_file(file, suffix="", download=True, hard=True):
    """Search/download file (if necessary) and return path."""
    check_suffix(file, suffix)  # optional
    file = str(file).strip()  # convert to string and strip spaces
    file = check_yolov5u_filename(file)  # yolov5n -> yolov5nu
    if (
        not file
        or ("://" not in file and Path(file).exists())  # '://' check required in Windows Python<3.10
        or file.lower().startswith("grpc://")
    ):  # file exists or gRPC Triton images
        return file
    elif download and file.lower().startswith(("https://", "http://", "rtsp://", "rtmp://", "tcp://")):  # download
        url = file  # warning: Pathlib turns :// -> :/
        file = url2file(file)  # '%2F' to '/', split https://url.com/file.txt?auth
        if Path(file).exists():
            LOGGER.info(f"Found {clean_url(url)} locally at {file}")  # file already exists
        else:
            downloads.safe_download(url=url, file=file, unzip=False)
        return file
    else:  # search
        files = glob.glob(str(ROOT / "**" / file), recursive=True) or glob.glob(str(ROOT.parent / file))  # find file
        if not files and hard:
            raise FileNotFoundError(f"'{file}' does not exist")
        elif len(files) > 1 and hard:
            raise FileNotFoundError(f"Multiple files match '{file}', specify exact path: {files}")
        return files[0] if len(files) else []  # return file
```

æœ€ç»ˆçš„è½è„šç‚¹å°±æ˜¯è¿™ä¸€å¥

`files = glob.glob(str(ROOT / "**" / file), recursive=True) or glob.glob(str(ROOT.parent / file))`

åœ¨`ROOT`æˆ–è€…`ROOT.parent`ä¸‹å¯»æ‰¾ç¬¦åˆåå­—çš„`yaml`æ–‡ä»¶ã€‚

å¦‚æœæ‰¾åˆ°ä¸æ­¢ä¸€ä¸ªæ€ä¹ˆåŠï¼Ÿå°±åªè¿”å›ç¬¬ä¸€ä¸ªã€‚

å¦‚æœæ²¡æ‰¾åˆ°æ€ä¹ˆåŠï¼Ÿå°±è¿”å›ä¸€ä¸ªç©ºåˆ—è¡¨ã€‚
