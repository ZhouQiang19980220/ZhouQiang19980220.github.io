---
layout: post
title: YOLOv8是如何通过yaml构建模型的?
tags: [YOLO]
author: Tenacity Wick
---
1. **Ultralytics**：[YOLOv8 的官方仓库](https://github.com/ultralytics/ultralytics)。
2. [如何安装 YOLOv8](https://zhouqiang19980220.github.io/2024-07-28-%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85YOLOv8/)
# YOLOv8是如何通过yaml构建模型的

## 一些教程

YOLOv8的核心代码在如下目录：`ultralytics/ultralytics`

一些使用示例和教程的代码`ultralytics/examples`

[教程](https://github.com/ZhouQiang19980220/ultralytics/blob/main/examples/tutorial.ipynb)

使用 python 构建模型、训练、测试、推理、部署

```python
from ultralytics import YOLO

# Load a model
model = YOLO('yolov8n.yaml')  # build a new model from scratch
model = YOLO('yolov8n.pt')  # load a pretrained model (recommended for training)

# Use the model
results = model.train(data='coco8.yaml', epochs=3)  # train the model
results = model.val()  # evaluate model performance on the validation set
results = model('https://ultralytics.com/images/bus.jpg')  # predict on an image
results = model.export(format='onnx')  # export the model to ONNX format
```

注意到`model = YOLO('yolov8n.yaml')  # build a new model from scratch`这行代码可以通过`yolov8n.yaml`来构建模型。

但是我在阅读源码的过程中，找了很久都没有找到这个所谓的`yolov8n.yaml`文件。最终在`ultralytics/cfg/models/v8/yolov8.yaml`找到了配置文件（注意这里的文件名不是`yolov8n.yaml`，而是`yolov8.yaml`），该文件的内容定义如下，大体分为 4 个部分

1. **通用参数的定义**`nc`：这里修改为自定义数据集的实际类别数；默认80 是因为 COCO 数据集中有 80 个类别。
2. **尺度**：从小到大共有 5 种不同尺度的模型。
3. **backbone 的定义**。
4. **head 的定义：需要用到`nc`这个参数**。

```yaml
# Ultralytics YOLO 🚀, AGPL-3.0 license
# YOLOv8 object detection model with P3-P5 outputs. For Usage examples see https://docs.ultralytics.com/tasks/detect

# Parameters
nc: 80 # number of classes
scales: # model compound scaling constants, i.e. 'model=yolov8n.yaml' will call yolov8.yaml with scale 'n'
  # [depth, width, max_channels]
  n: [0.33, 0.25, 1024] # YOLOv8n summary: 225 layers,  3157200 parameters,  3157184 gradients,   8.9 GFLOPs
  s: [0.33, 0.50, 1024] # YOLOv8s summary: 225 layers, 11166560 parameters, 11166544 gradients,  28.8 GFLOPs
  m: [0.67, 0.75, 768] # YOLOv8m summary: 295 layers, 25902640 parameters, 25902624 gradients,  79.3 GFLOPs
  l: [1.00, 1.00, 512] # YOLOv8l summary: 365 layers, 43691520 parameters, 43691504 gradients, 165.7 GFLOPs
  x: [1.00, 1.25, 512] # YOLOv8x summary: 365 layers, 68229648 parameters, 68229632 gradients, 258.5 GFLOPs

# YOLOv8.0n backbone
backbone:
  # [from, repeats, module, args]
  - [-1, 1, Conv, [64, 3, 2]] # 0-P1/2
  - [-1, 1, Conv, [128, 3, 2]] # 1-P2/4
  - [-1, 3, C2f, [128, True]]
  - [-1, 1, Conv, [256, 3, 2]] # 3-P3/8
  - [-1, 6, C2f, [256, True]]
  - [-1, 1, Conv, [512, 3, 2]] # 5-P4/16
  - [-1, 6, C2f, [512, True]]
  - [-1, 1, Conv, [1024, 3, 2]] # 7-P5/32
  - [-1, 3, C2f, [1024, True]]
  - [-1, 1, SPPF, [1024, 5]] # 9

# YOLOv8.0n head
head:
  - [-1, 1, nn.Upsample, [None, 2, "nearest"]]
  - [[-1, 6], 1, Concat, [1]] # cat backbone P4
  - [-1, 3, C2f, [512]] # 12

  - [-1, 1, nn.Upsample, [None, 2, "nearest"]]
  - [[-1, 4], 1, Concat, [1]] # cat backbone P3
  - [-1, 3, C2f, [256]] # 15 (P3/8-small)

  - [-1, 1, Conv, [256, 3, 2]]
  - [[-1, 12], 1, Concat, [1]] # cat head P4
  - [-1, 3, C2f, [512]] # 18 (P4/16-medium)

  - [-1, 1, Conv, [512, 3, 2]]
  - [[-1, 9], 1, Concat, [1]] # cat head P5
  - [-1, 3, C2f, [1024]] # 21 (P5/32-large)

  - [[15, 18, 21], 1, Detect, [nc]] # Detect(P3, P4, P5)
```

至此，我仍然有一些困惑

1. ``model = YOLO('yolov8n.yaml')`这行代码并没有给出`yolov8n.yaml`的路径，YOLO 是如何找到对应的文件的？

   一个简单的想法是预定义了yaml 文件的地址，然后直接到预定义的目录中寻找即可（事实上不是这样的）

2. 构建模型时传入的参数是`yolov8n.yaml`，但是我找到的 `yaml`却是`yolov8.yaml`。

## YOLOv8是如何通过yaml构建模型的

### 准备工作

1. 按照[教程](https://zhouqiang19980220.github.io/2024-07-28-%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85YOLOv8/)安装 YOLOv8。

2. 安装 [viztracer](https://github.com/gaogaotiantian/viztracer)

   > VizTracer is a low-overhead logging/debugging/profiling tool that can trace and visualize your python code execution.
   >
   > The front-end UI is powered by Perfetto. Use "AWSD" to zoom/navigate. More help can be found in "Support - Controls".

​		上面是 viztracer 官方仓库的介绍，开发者是 python core dev：码农高天。

### 使用viztracer追踪代码的调用过程

1. 新建一个python 文件，内容如下

   ```python
   from ultralytics import YOLO
   
   model = YOLO('yolov8n.yaml')
   ```

2. 使用 viztracer 执行上面的 py 文件。

   ```bash
   viztracer <python-file.py>
   ```

   执行完成后会生成一个`result.json`的文件

3. 使用 vizviewer可视化`result.json`

   ```bash
   vizviewer result.json
   ```

   如果在远程开发，没有可视化环境，可以将`result.json`下载到本地后再运行上述命令

   默认情况下，使用浏览器打开`http://127.0.0.1:9001/`即可。

   可视化界面如下，可以很方便的观察函数的调用关系。

   ![image-20240728124952200](https://p.ipic.vip/j0rac4.png)

# 函数的调用关系

1. `ultralytics/models/yolo/model.py`

`super().__init__(model=model, task=task, verbose=verbose)`

```python
class YOLO(Model):
    """YOLO (You Only Look Once) object detection model."""

    def __init__(self, model="yolov8n.pt", task=None, verbose=False):
        """Initialize YOLO model, switching to YOLOWorld if model filename contains '-world'."""
        path = Path(model)
        if "-world" in path.stem and path.suffix in {".pt", ".yaml", ".yml"}:  # if YOLOWorld PyTorch model
            new_instance = YOLOWorld(path, verbose=verbose)
            self.__class__ = type(new_instance)
            self.__dict__ = new_instance.__dict__
        else:
            # Continue with default YOLO initialization
            super().__init__(model=model, task=task, verbose=verbose)
```

2. `ultralytics/ultralytics/engine/model.py`

`self._new(model, task=task, verbose=verbose)`

```python
class Model(nn.Module):
    def __init__(
        self,
        model: Union[str, Path] = "yolov8n.pt",
        task: str = None,
        verbose: bool = False,
    ) -> None:
        super().__init__()
        self.callbacks = callbacks.get_default_callbacks()
        self.predictor = None  # reuse predictor
        self.model = None  # model object
        self.trainer = None  # trainer object
        self.ckpt = None  # if loaded from *.pt
        self.cfg = None  # if loaded from *.yaml
        self.ckpt_path = None
        self.overrides = {}  # overrides for trainer object
        self.metrics = None  # validation/training metrics
        self.session = None  # HUB session
        self.task = task  # task type
        model = str(model).strip()

        # Check if Ultralytics HUB model from https://hub.ultralytics.com
        if self.is_hub_model(model):
            # Fetch model from HUB
            checks.check_requirements("hub-sdk>=0.0.8")
            self.session = HUBTrainingSession.create_session(model)
            model = self.session.model_file

        # Check if Triton Server model
        elif self.is_triton_model(model):
            self.model_name = self.model = model
            return

        # Load or create new YOLO model
        if Path(model).suffix in {".yaml", ".yml"}:
            self._new(model, task=task, verbose=verbose)
        else:
            self._load(model, task=task)
```

3. `ultralytics/ultralytics/engine/model.py`

`cfg_dict = yaml_model_load(cfg)`

```python
def _new(self, cfg: str, task=None, model=None, verbose=False) -> None:

        cfg_dict = yaml_model_load(cfg)
        self.cfg = cfg
        self.task = task or guess_model_task(cfg_dict)
        self.model = (model or self._smart_load("model"))(cfg_dict, verbose=verbose and RANK == -1)  					# build model
        self.overrides["model"] = self.cfg
        self.overrides["task"] = self.task

        # Below added to allow export from YAMLs
        self.model.args = {**DEFAULT_CFG_DICT, **self.overrides} 
        self.model.task = self.task
        self.model_name = cfg
```

4. `ultralytics/ultralytics/nn/tasks.py`

`yaml_file = check_yaml(unified_path, hard=False) or check_yaml(path)`

```python
def yaml_model_load(path):
    """Load a YOLOv8 model from a YAML file."""
    import re

    path = Path(path)
    if path.stem in (f"yolov{d}{x}6" for x in "nsmlx" for d in (5, 8)):
        new_stem = re.sub(r"(\d+)([nslmx])6(.+)?$", r"\1\2-p6\3", path.stem)
        LOGGER.warning(f"WARNING ⚠️ Ultralytics YOLO P6 models now use -p6 suffix. Renaming {path.stem} to {new_stem}.")
        path = path.with_name(new_stem + path.suffix)

    unified_path = re.sub(r"(\d+)([nslmx])(.+)?$", r"\1\3", str(path))  # i.e. yolov8x.yaml -> yolov8.yaml
    yaml_file = check_yaml(unified_path, hard=False) or check_yaml(path)
    d = yaml_load(yaml_file)  # model dict
    d["scale"] = guess_model_scale(path)
    d["yaml_file"] = str(path)
    return d
```

5. `ultralytics/ultralytics/utils/checks.py`

```python
def check_yaml(file, suffix=(".yaml", ".yml"), hard=True):
    """Search/download YAML file (if necessary) and return path, checking suffix."""
    return check_file(file, suffix, hard=hard)
```

6. `ultralytics/ultralytics/utils/checks.py`

```python
def check_file(file, suffix="", download=True, hard=True):
    """Search/download file (if necessary) and return path."""
    check_suffix(file, suffix)  # optional
    file = str(file).strip()  # convert to string and strip spaces
    file = check_yolov5u_filename(file)  # yolov5n -> yolov5nu
    if (
        not file
        or ("://" not in file and Path(file).exists())  # '://' check required in Windows Python<3.10
        or file.lower().startswith("grpc://")
    ):  # file exists or gRPC Triton images
        return file
    elif download and file.lower().startswith(("https://", "http://", "rtsp://", "rtmp://", "tcp://")):  # download
        url = file  # warning: Pathlib turns :// -> :/
        file = url2file(file)  # '%2F' to '/', split https://url.com/file.txt?auth
        if Path(file).exists():
            LOGGER.info(f"Found {clean_url(url)} locally at {file}")  # file already exists
        else:
            downloads.safe_download(url=url, file=file, unzip=False)
        return file
    else:  # search
        files = glob.glob(str(ROOT / "**" / file), recursive=True) or glob.glob(str(ROOT.parent / file))  # find file
        if not files and hard:
            raise FileNotFoundError(f"'{file}' does not exist")
        elif len(files) > 1 and hard:
            raise FileNotFoundError(f"Multiple files match '{file}', specify exact path: {files}")
        return files[0] if len(files) else []  # return file
```

最终的落脚点就是这一句

`files = glob.glob(str(ROOT / "**" / file), recursive=True) or glob.glob(str(ROOT.parent / file))`

在`ROOT`或者`ROOT.parent`下寻找符合名字的`yaml`文件。

如果找到不止一个怎么办？就只返回第一个。

如果没找到怎么办？就返回一个空列表。
